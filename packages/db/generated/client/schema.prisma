generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
  output        = "../generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         Int     @id @default(autoincrement())
  auth_id    String  @unique
  email      String  @unique
  first_name String?
  last_name  String?

  githubAuth GithubAuth? @relation

  created_at DateTime @default(now()) @db.Timestamptz(3)
  updated_at DateTime @updatedAt @db.Timestamptz(3)

  @@map("users")
}

enum GithubAuthRepoSelection {
  ALL
  SELECTED

  @@map("github_auth_repo_selection")
}

enum InstallationRepoOwnerType {
  USER
  ORGANIZATION

  @@map("installation_repo_owner_type")
}

enum InstallationRepoVisibility {
  PUBLIC
  PRIVATE
  INTERNAL

  @@map("installation_repo_visibility")
}

model GithubAuth {
  id Int @id @default(autoincrement())

  // --- Relation to your app user ---
  user_id Int  @unique
  user    User @relation(fields: [user_id], references: [id])

  // --- User OAuth ---
  github_user_id     Int? // --
  github_username    String? // --
  github_avatar_url  String? // These are optional since based on the auth flow used, this can only be added when github's /user endpoint is hit and that's done in the background process after installing the github app
  access_token       String
  refresh_token      String
  token_type         String // usually "bearer"
  expires_at         DateTime @db.Timestamptz(3)
  refresh_expires_at DateTime @db.Timestamptz(3)
  scope              String // usually empty string

  // --- App Installation ---
  installation_id               String                  @unique
  installation_token_expires_at DateTime
  permissions                   Json
  repository_selection          GithubAuthRepoSelection

  created_at DateTime @default(now()) @db.Timestamptz(3)
  updated_at DateTime @updatedAt @db.Timestamptz(3)

  // Relation: one installation â†” many repos
  repos GithubInstallationRepos[]

  @@map("github_auth")
}

model GithubInstallationRepos {
  // Composite PK keeps rows tiny and prevents duplicates per installation
  installation_id String
  repo_id         BigInt @db.BigInt

  // Tiny, useful fields only
  full_name      String // "owner/name" (UI + unique-ish handle)
  name           String // "name"
  owner_username String // "owner"
  owner_type     InstallationRepoOwnerType // "User" | "Organization" (kept as String for simplicity)
  visibility     InstallationRepoVisibility? // "public" | "private" | "internal"
  archived       Boolean                     @default(false)
  disabled       Boolean                     @default(false)
  default_branch String?
  html_url       String
  language       String?

  // Sync bookkeeping
  fetched_at DateTime  @default(now()) @db.Timestamptz(3)
  deleted_at DateTime? @db.Timestamptz(3)

  created_at DateTime @default(now()) @db.Timestamptz(3)
  updated_at DateTime @updatedAt @db.Timestamptz(3)

  // Relation back to GithubAuth via unique installation_id
  githubAuth GithubAuth @relation(fields: [installation_id], references: [installation_id], onDelete: Cascade)

  @@id([installation_id, repo_id])
  @@index([installation_id, full_name])
  @@index([installation_id, owner_username])
  @@map("github_installation_repos")
}
